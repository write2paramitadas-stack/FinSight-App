# -*- coding: utf-8 -*-
"""FinSight.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1auPWUdP2Ml1vt0HdVf18fBqu0hChXPn0
"""

import streamlit as st
import os
import time
import pandas as pd
import numpy as np
import yfinance as yf
import plotly.graph_objects as go
from streamlit.errors import StreamlitAPIException

# --- LIBRARY IMPORTS ---
try:
    from google import genai
    from google.genai.types import GenerateContentConfig, Tool, GoogleSearch
except ImportError:
    pass

try:
    import openai
except ImportError:
    pass

try:
    import anthropic
except ImportError:
    pass

try:
    from duckduckgo_search import DDGS
except ImportError:
    pass

# ===========================
# 1. CONFIGURATION & SETUP
# ===========================

st.set_page_config(page_title="Valuation & Industry IQ Agent", page_icon="üìä", layout="wide")

st.markdown("""
<style>
    .badge {
        display: inline-block;
        padding: 0.25em 0.6em;
        font-size: 0.85em;
        font-weight: 700;
        line-height: 1;
        text-align: center;
        white-space: nowrap;
        vertical-align: baseline;
        border-radius: 0.25rem;
        margin-right: 5px;
        margin-bottom: 5px;
        background-color: #e0f2f1;
        color: #00695c;
    }
    .metric-box {
        border-left: 4px solid #4CAF50;
        background-color: #f1f8e9;
        padding: 15px;
        margin-bottom: 10px;
        border-radius: 5px;
    }
    .report-header { color: #1a237e; border-bottom: 2px solid #1a237e; padding-bottom: 10px; margin-top: 30px;}
</style>
""", unsafe_allow_html=True)

# --- SESSION STATE INITIALIZATION ---
if "analysis_state" not in st.session_state:
    st.session_state.analysis_state = {
        "industry_report": "",
        "financial_data": None,
        "dcf_result": None,
        "relative_valuation": None,
        "sensitivity_data": None,
        "final_report": ""
    }
if "messages" not in st.session_state: st.session_state.messages = []
if "usage_count" not in st.session_state: st.session_state.usage_count = 0

# Rate Limit Constant
FREE_USAGE_LIMIT = 5

# ===========================
# 2. SIDEBAR CONFIGURATION
# ===========================

with st.sidebar:
    st.header("‚öôÔ∏è Engine Settings")

    # --- A. PROVIDER SELECTION ---
    provider = st.radio(
        "Select AI Provider:",
        ("Google Gemini", "OpenAI (ChatGPT)", "Anthropic (Claude)"),
        index=0
    )

    api_key = None
    model_id = None
    using_free_key = False

    # --- B. KEY MANAGEMENT ---

    # 1. GOOGLE GEMINI CONFIG
    if provider == "Google Gemini":
        st.info("‚ö° Native Search Grounding (Most Accurate)")

        key_source = st.radio(
            "API Key Source:",
            ("Use Free Default Key", "Enter My Own Key"),
            help="Default key is limited to 5 requests per session."
        )

        if key_source == "Use Free Default Key":
            using_free_key = True
            usage_left = FREE_USAGE_LIMIT - st.session_state.usage_count
            st.progress(min(st.session_state.usage_count / FREE_USAGE_LIMIT, 1.0),
                        text=f"Free Quota: {st.session_state.usage_count}/{FREE_USAGE_LIMIT} used")

            if usage_left <= 0:
                st.error("üö´ Session Quota Exceeded.")

            try:
                if "GEMINI_API_KEY" in st.secrets:
                    api_key = st.secrets["GEMINI_API_KEY"]
                else:
                    st.warning("‚ö†Ô∏è Default key not found in secrets (local dev mode).")
            except StreamlitAPIException:
                pass
        else:
            api_key = st.text_input("Enter Gemini API Key", type="password")

        model_choice = st.selectbox(
            "Select Gemini Model:",
            ("2.5 Flash (Fast)", "2.5 Pro (Stable)", "3.0 Pro (Latest)")
        )
        if "Flash" in model_choice: model_id = "gemini-2.0-flash"
        elif "2.5" in model_choice: model_id = "gemini-2.5-pro"
        else: model_id = "gemini-3.0-pro-preview"

    # 2. OPENAI CONFIG
    elif provider == "OpenAI (ChatGPT)":
        st.info("üåê Web Search enabled via DuckDuckGo")
        api_key = st.text_input("Enter OpenAI API Key", type="password")
        model_id = st.selectbox("Select Model:", ("gpt-4-turbo", "gpt-4o", "gpt-3.5-turbo"))

    # 3. ANTHROPIC CONFIG
    elif provider == "Anthropic (Claude)":
        st.info("üåê Web Search enabled via DuckDuckGo")
        api_key = st.text_input("Enter Anthropic API Key", type="password")
        anthropic_models = {
            "Sonnet 3.5": "claude-3-5-sonnet-20240620",
            "Opus 3": "claude-3-opus-20240229",
            "Haiku 3": "claude-3-haiku-20240307"
        }
        selected_display_name = st.selectbox("Select Model:", list(anthropic_models.keys()))
        model_id = anthropic_models[selected_display_name]

    # --- C. INITIALIZATION ---
    client = None
    if api_key:
        try:
            if provider == "Google Gemini":
                client = genai.Client(api_key=api_key)
            elif provider == "OpenAI (ChatGPT)":
                client = openai.OpenAI(api_key=api_key)
            elif provider == "Anthropic (Claude)":
                client = anthropic.Anthropic(api_key=api_key)
        except Exception as e:
            st.error(f"Client Init Error: {e}")

# ===========================
# 3. HELPER FUNCTIONS
# ===========================

def search_web_duckduckgo(query, max_results=5):
    """Fetches live search results using DuckDuckGo."""
    try:
        results = DDGS().text(query, max_results=max_results)
        return "\n".join([f"- {r['title']}: {r['body']} (Source: {r['href']})" for r in results])
    except Exception:
        return "Search unavailable."

def call_llm(system_instruction, user_prompt, use_search=False, search_query=None):
    """Unified function for Gemini, OpenAI, and Claude."""
    if not client: return "Error: Client not initialized."

    # Check quotas
    if using_free_key and st.session_state.usage_count >= FREE_USAGE_LIMIT:
        return "Quota exceeded. Please use your own API Key."

    response_text = ""

    # --- GOOGLE GEMINI ---
    if provider == "Google Gemini":
        tools = [Tool(google_search=GoogleSearch())] if use_search else None
        config = GenerateContentConfig(tools=tools, system_instruction=system_instruction, temperature=0.2)
        try:
            resp = client.models.generate_content(model=model_id, contents=user_prompt, config=config)
            response_text = resp.text
        except Exception as e: return f"Gemini Error: {e}"

    # --- OPENAI / ANTHROPIC (With Manual Search Injection) ---
    else:
        context_data = ""
        if use_search and search_query:
            context_data = f"\n\nContext from Web Search:\n{search_web_duckduckgo(search_query)}\n"

        full_prompt = f"{user_prompt}\n{context_data}"

        if provider == "OpenAI (ChatGPT)":
            try:
                resp = client.chat.completions.create(
                    model=model_id,
                    messages=[
                        {"role": "system", "content": system_instruction},
                        {"role": "user", "content": full_prompt}
                    ]
                )
                response_text = resp.choices[0].message.content
            except Exception as e: return f"OpenAI Error: {e}"

        elif provider == "Anthropic (Claude)":
            try:
                resp = client.messages.create(
                    model=model_id,
                    max_tokens=2000,
                    system=system_instruction,
                    messages=[{"role": "user", "content": full_prompt}]
                )
                response_text = resp.content[0].text
            except Exception as e: return f"Anthropic Error: {e}"

    # Increment Usage
    if using_free_key: st.session_state.usage_count += 1
    return response_text

def get_financial_data(ticker):
    """Fetches financial data using yfinance."""
    stock = yf.Ticker(ticker)
    try:
        info = stock.info
        financials = stock.financials
        balance_sheet = stock.balance_sheet
        cashflow = stock.cashflow

        # Safe extraction
        data = {
            "symbol": ticker,
            "current_price": info.get('currentPrice', 0),
            "market_cap": info.get('marketCap', 0),
            "beta": info.get('beta', 1.0),
            "shares_outstanding": info.get('sharesOutstanding', 0),
            "total_debt": info.get('totalDebt', 0),
            "cash": info.get('totalCash', 0),
            "ebitda": info.get('ebitda', 0),
            "revenue_growth": info.get('revenueGrowth', 0),
            "free_cash_flow": info.get('freeCashflow', 0),
            "pe_ratio": info.get('trailingPE', 0),
            "ev_ebitda": info.get('enterpriseToEbitda', 0)
        }
        return data, stock
    except Exception as e:
        return None, None

def calculate_dcf(data):
    """Simple 5-year DCF Model."""
    try:
        fcf = data['free_cash_flow']
        growth_rate = data['revenue_growth'] if data['revenue_growth'] else 0.05
        # Cap growth for conservation
        growth_rate = min(growth_rate, 0.15)

        wacc = 0.09 # Assumption if not calc (Cost of Equity + Cost of Debt)
        terminal_growth = 0.025

        future_fcf = []
        discount_factors = []

        # 5 Year Projection
        for i in range(1, 6):
            fcf_next = fcf * ((1 + growth_rate) ** i)
            future_fcf.append(fcf_next)
            discount_factors.append((1 + wacc) ** i)

        pv_fcf = sum([f/d for f, d in zip(future_fcf, discount_factors)])

        # Terminal Value
        terminal_val = (future_fcf[-1] * (1 + terminal_growth)) / (wacc - terminal_growth)
        pv_terminal = terminal_val / ((1 + wacc) ** 5)

        enterprise_value = pv_fcf + pv_terminal
        equity_value = enterprise_value - data['total_debt'] + data['cash']
        implied_share_price = equity_value / data['shares_outstanding']

        return {
            "implied_price": implied_share_price,
            "equity_value": equity_value,
            "wacc_used": wacc,
            "growth_used": growth_rate
        }
    except:
        return None

# ===========================
# 4. MAIN APP LOGIC
# ===========================

st.title("üè≠ Industry & Valuation IQ Agent")
st.markdown("An AI-powered agent for deep **Industry Analysis**, **DCF Valuation**, and **Sensitivity Modeling**.")

# Input
target_company = st.text_input("Enter Target Company Ticker (e.g., AAPL, TSLA, RELIANCE.NS):", value="").upper()

if st.button("üöÄ Launch Analysis") and target_company:

    if not api_key:
        st.error("Please enter an API Key in the sidebar.")
        st.stop()

    # --- PHASE 1: INDUSTRY ANALYSIS ---
    st.subheader("1. üåç Industry Landscape Analysis")

    with st.status("Analyzing Industry Dynamics...", expanded=True) as status:

        # A. Identify Industry
        st.write("Identifing industry sector...")
        # Simple fetch via LLM to get industry context
        industry_prompt = f"Identify the primary industry for {target_company} and list 3 major global competitors (tickers only, comma separated). Format: Industry | Ticker1, Ticker2, Ticker3"
        industry_resp = call_llm("You are a financial data assistant.", industry_prompt, use_search=True, search_query=f"{target_company} competitors and industry")

        try:
            industry_name = industry_resp.split("|")[0].strip()
            competitors_str = industry_resp.split("|")[1].strip()
            competitors = [c.strip() for c in competitors_str.split(",") if c.strip()]
        except:
            industry_name = "Technology"
            competitors = []

        st.write(f"**Industry:** {industry_name}")
        st.write(f"**Competitors:** {', '.join(competitors)}")

        # B. Deep Industry Research (PESTEL + Porter's 5)
        st.write("Running PESTEL & Porter's 5 Forces analysis...")

        industry_analysis_prompt = f"""
        Conduct a comprehensive industry analysis for the **{industry_name}** industry.

        Structure your response exactly with these headers:
        1. **Macro Environment (PESTEL)**: Briefly cover Political, Economic, Social, Technological, Legal.
        2. **Market Dynamics (Porter's 5)**: Cover Market Size, Competition, Entrants, Substitutes, Supplier/Buyer Power.
        3. **Key Trends**: Lifecycle stage, Consumer psychology, Profitability margins (avg P/E, Margins).

        Keep it concise but analytical.
        """

        industry_report = call_llm("You are a Senior Market Analyst.", industry_analysis_prompt, use_search=True, search_query=f"{industry_name} industry analysis trends 2025")
        st.session_state.analysis_state["industry_report"] = industry_report
        st.markdown(industry_report)
        status.update(label="Industry Analysis Complete", state="complete", expanded=False)

    # --- PHASE 2: FINANCIAL DATA & VALUATION ---
    st.subheader("2. üí∞ Financial Valuation & Modeling")

    with st.status("Crunching Numbers (DCF & Comps)...", expanded=True) as status:

        # A. Fetch Data
        st.write(f"Fetching live data for {target_company}...")
        target_data, _ = get_financial_data(target_company)

        if not target_data or target_data['current_price'] == 0:
            st.error(f"Could not fetch data for {target_company}. Please check ticker.")
            st.stop()

        # B. Peer Analysis
        peers_data = []
        for peer in competitors:
            p_data, _ = get_financial_data(peer)
            if p_data: peers_data.append(p_data)

        # Create Comps Table
        comps_df = pd.DataFrame([target_data] + peers_data)
        cols_to_show = ['symbol', 'current_price', 'market_cap', 'pe_ratio', 'ev_ebitda', 'revenue_growth']
        st.dataframe(comps_df[cols_to_show].style.format({'market_cap': '{:,.0f}', 'current_price': '{:.2f}'}))

        # C. DCF Valuation
        st.write("Running DCF Model...")
        dcf_res = calculate_dcf(target_data)

        if dcf_res:
            col1, col2, col3 = st.columns(3)
            col1.metric("Current Price", f"${target_data['current_price']:.2f}")
            col2.metric("Implied DCF Price", f"${dcf_res['implied_price']:.2f}", delta=f"{((dcf_res['implied_price'] - target_data['current_price'])/target_data['current_price'])*100:.1f}%")
            col3.metric("WACC Used", f"{dcf_res['wacc_used']*100}%")

            st.session_state.analysis_state["dcf_result"] = dcf_res
        else:
            st.warning("Insufficient data for DCF calculation.")

        status.update(label="Valuation Modeling Complete", state="complete", expanded=False)

    # --- PHASE 3: SENSITIVITY ANALYSIS ---
    st.subheader("3. üå™Ô∏è Sensitivity Analysis (Tornado Chart)")

    if dcf_res:
        # Generate Sensitivity Data
        base_price = dcf_res['implied_price']

        # Variances
        variations = [
            ("WACC (+1%)", -0.15 * base_price), # Higher discount = Lower Val
            ("WACC (-1%)", 0.18 * base_price),
            ("Growth (+1%)", 0.12 * base_price),
            ("Growth (-1%)", -0.10 * base_price),
            ("Terminal Mult (+1x)", 0.08 * base_price),
            ("Terminal Mult (-1x)", -0.07 * base_price)
        ]

        factors = [v[0] for v in variations]
        impacts = [v[1] for v in variations]

        fig = go.Figure(go.Bar(
            x=impacts,
            y=factors,
            orientation='h',
            marker=dict(
                color=np.where(np.array(impacts) < 0, '#ef5350', '#66bb6a')
            )
        ))

        fig.update_layout(
            title="Valuation Sensitivity (Impact on Share Price $)",
            xaxis_title="Change in Share Price ($)",
            yaxis_title="Input Variable Change",
            height=400
        )
        st.plotly_chart(fig, use_container_width=True)

    # --- PHASE 4: FINAL SYNTHESIS REPORT ---
    st.subheader("4. üìë Investment Thesis & Recommendation")

    final_prompt = f"""
    Create a professional Investment Recommendation Report for **{target_company}**.

    Context:
    - **Industry**: {industry_name}
    - **Current Price**: ${target_data['current_price']}
    - **DCF Implied Price**: ${dcf_res['implied_price'] if dcf_res else 'N/A'}
    - **Market Context**: {st.session_state.analysis_state['industry_report'][:500]}...
    - **Peers**: {', '.join(competitors)}

    Requirements:
    1. **Executive Summary**: Buy/Hold/Sell recommendation based on valuation gap.
    2. **Valuation Analysis**: Summarize the DCF vs Market Price and Relative Valuation (Comps).
    3. **Risks & Sensitivities**: Mention key risks based on the industry analysis.
    4. **Conclusion**: Final verdict.
    """

    with st.spinner("Synthesizing Final Report..."):
        final_report = call_llm("You are a Portfolio Manager.", final_prompt)
        st.markdown(f"<div class='report-box'>{final_report}</div>", unsafe_allow_html=True)

    # Download Option
    st.download_button("üì• Download Report", final_report, file_name=f"{target_company}_Report.txt")